== 1. Introduction ==
This article describes contract language for meta contracts. The aim is to provide a language that
is powerful enough to express relevant properties of functions alongside regular contracts and , yet,
sufficiently constrained so as to avoid undecidability and specification of irrelevant properties.
By relevant properties we mean those properties of functions that could be exploited to ensure preservation
of sequential semantics in concurrent execution. 

As discussed in the previous report on profile based solution, We are interested in preservation and
dependence on elts and struc of the input. We are also interested in value property of input which describes
certain properties (like non-zero'ness) on the value of input. These properties are formally defined in section 2.

== 2. The Language == 
=== 2.1 Key Words ===
Similar to regular contract language contructs like ensures, requires, signals etc, meta contract language has two basic contructs -
preserves and decided-by. Preserves is used to declare that the function preserves certain property of its input whereas decided-by is
to declare the property of input that is sufficient to decide the output of the function. The language contrains the set of properties 
to elts, struc and value. An example of a contract in racket using above mentioned constructs is given below -

  QuickSortContract =
    qsort : (l1 : List Pos) (Pos->Pos->Bool) -> (l2 : List Pos)
    and preserves elts of l1 in l2
    
  FindMinContract =
    findmin : (l1 : List Pos) (Pos->Pos->Bool) -> (Pos)
    and decided-by elts of l1

=== 2.2 Definitions ===
# Preservation - A property <math>P:T1\rightarrow T2</math> is said to be preserved by function <math>f:T1\rightarrow \beta \rightarrow T1</math> if and only if <math>\forall x:T1,\forall y:\beta ,\quad (P(x)=P(f\quad x\quad y)</math>
# Decided-by - A function <math>f:T1\rightarrow \beta \rightarrow T2</math> is said to depend-on on a property <math>P:T1\rightarrow bool</math> if and only if <math>\forall x1,x2:T1,\quad \forall y1,y2:\beta ,\quad (P(x1) = P(x2))\Rightarrow (f\quad x1\quad y1=f\quad x2\quad y2)</math> <br />
# Elts - let <math>\beta=\sum _{ i=1 }^{ n }{ { C }_{ i }(\prod _{  }^{  }{ { \alpha  }_{ j } } ) } </math> be a sum-of-products style definition of a datatype <math>\beta</math> such that any <math>{ \alpha }_{ j }</math> need not be necessary different from <math>\beta</math>. Let <math>b={ C }_{ i }({ a }_{ j },{ a }_{ j+1 },...,{ a }_{ m })</math> be a value of type <math>\beta</math>. Then, elts b is defined as following - <br/> <math>elts(b)\quad =\quad set({ a }_{ j })\quad \cup \quad set({ a }_{ j+1 })\quad \cup \quad ...\quad \cup \quad set({ a }_{ m })</math>, where <br /> <math>set({ a }_{ j })\quad =\quad elts\quad { a }_{ j },\quad if\quad { a }_{ j }:\beta </math>, and <br /> <math>set({ a }_{ j })\quad =\quad \{ { a }_{ j }\} ,\quad otherwise</math>
# Struc - Let us define a datatype structure as following <br /><math>datatype \quad structure = ConsStruc \quad of \quad String</math><br /> The only operation defined on structure type is regex match (<math>\cong</math>). For the same definitions of <math>\beta</math> and b as above, struc b is defined as below - <br /> <math>struc(b) \quad=ConsStruc \quad toString(b)</math>, where <br /><math>toString(b)\quad=\quad '{ (c }_{ i }'+str({ a }_{ j })+str({ a }_{ j+1 })+...+str({ a }_{ m })+')'</math>, and<br /> <math>str({ a }_{ j })\quad =\quad toString({ a }_{ j }),\quad if\quad { a }_{ j }:\beta </math>, and<br /> <math>str({ a }_{ j })\quad =\quad '()',\quad otherwise</math><br /> where '+' represents string concatenation in the above definition
# Value - For the above definition of b, value b is defined as following - <br /><math>value(b)\quad =\quad b</math>

=== 2.3 Filters ===
Elts, struc and value are too strict properties for many functions to preserve and too liberal for many functions to be decided-by. Most of the interesting functions in standard library preserve and depend on a sub-set of these properties. To specify such sub-sets, we have filters. A Filter is a predicate that takes a value and outputs either true or false. We will then have generic wrappers to apply the filters on sets generated by elts, struc and value to output filtered sets. 

Formally, a filter <math>\rho :\alpha \rightarrow bool</math> is a conjunction or disjunction of predicates from the set <math>\{ \upsilon \ge \chi ,\quad \upsilon \le \chi ,\quad \upsilon >\chi ,\quad \upsilon <\chi ,\quad \upsilon \cong \chi ,\quad \upsilon \neq \chi \} </math> which is parametrized on <math>\upsilon</math>. The variable <math>\chi</math> in the predicate can be instantiated by constants or any program variable in the current scope, including arguments of the current function. An example of <math>\rho</math> is <math>\lambda \upsilon .\upsilon \le 2</math>.

The filters thus defined are applied to the set of values described by elts, struc and value to produce a sub-set of values (thus liberalizing preservation condition and tightening decided-by condition). The evaluation rules for properties (elts, struc and value) qualified by filters are given below - 

# Let <math>\rho :\alpha \rightarrow bool</math> and let elts(b) = S be set of elements in b. Then, <math>\rho \quad  elts(b) = \{ x\in S\quad |\quad (x:\alpha \quad \wedge \quad \rho (x)=true)\quad \vee \quad (x:\alpha '\quad \wedge \quad \alpha '\nless :\alpha )\} </math>
# Let <math>\rho :Structure \rightarrow bool</math> and let struc(b) = S be a value of type Structure. Then, <math>\rho \quad struc(b) = (\rho (S)?\quad $1\quad :\quad \bot )</math>. Since regex match (<math>\cong</math>) is the only operation defined on Structure type, $1 will be populated with 1st capture group in the regular expression (Typing rules are needed for regex sanity so that we have atleast one capture group. An idea is to have a syntactic sugaring over string regular expression. Will be elaborated later.). 
# Let <math>\rho :\alpha \rightarrow bool</math> and let <math>b:\alpha</math>. Then <math>\rho \quad value(b) = (\rho \quad b)?true:false</math>.

== 3. Examples ==
Following examples give meta contracts that are written using the language introduced so far -
  BTreeInsertContract =
   btree_insert : (t1 : Any tree) (kvpair:Any) -> (t2 : Any tree)
   and preserves (!=kvpair) elts of t1 in t2
  BTreeLookupContract = 
   btree_lookup : (t1: Any tree) (key: Any) -> (val: Any)
   and decided-by (=(key,_)) elts of t1

  Btree_lsubtree_height : (t1: Any tree) -> (kvpair: Any)
  and decided-by (~=(\(.*\))\(\)(\(:?.*\))) struc of t1
  /* The first group in above regex captures constructor pattern for left subtree */

  map_double (l1: Any List) -> (l2: Any list)
  and preserves (>0) value of l1 in l2
  and preserves (<0) value of l1 in l2
  and preserves (=0) value of l1 in l2

== 4. Subtyping and parallelism ==
let <math>f:T1\rightarrow \alpha \rightarrow T1</math> preserves <math>{ \rho  }_{ 1 }P</math> and <math>g:T1\rightarrow \beta \rightarrow T2</math> is decided-by <math>{ \rho  }_{ 2 }P</math>, where <math>{ \rho  }_{ 1 }</math> and <math>{ \rho  }_{ 2 }</math> are filters and <math>P \in \quad \{ elts,struc,value\} </math>. Then,

# Claim 1 - <math>({ \rho  }_{ 2 }\Rightarrow { \rho  }_{ 1 }) \Rightarrow (f;g\quad { \longleftrightarrow  }_{ s }f||g)</math>, and
# Claim 2 - <math>(\phi \vdash { \rho  }_{ 2 }\Rightarrow { \rho  }_{ 1 })\Rightarrow (\phi \vdash f;g\quad { \longleftrightarrow  }_{ s }f||g)</math>

Claim 1 is, infact, a derivative of claim 2 where <math>\phi = true</math>

Example - Consider BTreeInsertContract and BTreeLookupContract in section 3. It is easy to notice that <math>((key,\_ )\neq kvpair)\vdash (\nu =(key,\_ ))\Rightarrow (\nu \neq kvpair)</math>. Now, <math>(key,\_ )\neq kvpair</math> is exactly the condition under which btree_insert and btree_lookup can be executed concurrently.

== 5. ToDo ==
The work is still very rudimentary. The following are the questions that need immediate attention -
# How do we check the 'decided-by' part of the contract?
# Compiler optimizations for amortizing contract checks are yet to be worked on.
# How can we generate <math>\phi</math> in case of claim 2? What should be the general procedure?
# Regular expression subtyping (<math>(Regex R2) \Rightarrow (Regex R1) ?</math>) has to be formalized. Currently, we depend on the notion that if string parsed by R2 is a substring of string parsed by R1, then R2 is a sub-type of R1. A good amount of previous work exists in regular expression subtyping for xml typedecs that can be made use of.
# How can we deal with functions? That is, what if the T1 in above definition is an arrow type? We chose to ignore this case for time-being until we hit a real example.
# How to Deal with cases like "Preserves elements in l2 that doesn't occur in l1" or "decided-by least element in l1"? One idea is to allow <math>\chi</math> in the definition of filters to be instantiated by a representative variable (say, x) of elts. Ex:

  findmin : (l1 : List Any as [x+]) -> Any
  findmin decided-by (<=x) (elts) of l1.

This can be interpreted as "findmin depends of those elements of l1 which are less than or equal to all elements of l1", which essentially evaluates to the least element. Another example is given below -
 
  Difference : (S1 : Set Pos) -> (S2 : Set Pos as {x2+}) -> (S : Set Pos)
  and preserves (!=x2) elts of S1) in S

What it means is "Difference preserves those elements of S1 that are not equal to any element in S2"

However, it is still not known whether this feature makes asserting claim-2 undecidable. Also, it is unclear as to how these kind of checks need to be amortized using compiler optimizations.

